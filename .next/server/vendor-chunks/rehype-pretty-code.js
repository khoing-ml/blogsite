"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n  return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n  return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n  return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent, bypass = false) {\n  if (bypass) {\n    return false;\n  }\n  return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n  return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n  const placeholder = \"\\0\";\n  let temp = meta.replace(/\\\\\\\\/g, placeholder);\n  temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n  const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n  return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n  let meta = filter(\n    element.data?.meta ?? element.properties?.metastring ?? \"\"\n  );\n  const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n  const title = titleMatch?.[1] ?? null;\n  meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n  const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n  const caption = captionMatch?.[1] ?? null;\n  meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n  let lang = defaultFallback;\n  if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n    lang = element.properties.className[0].replace(\"language-\", \"\");\n  }\n  return {\n    title,\n    caption,\n    lang,\n    meta\n  };\n}\nfunction getThemeNames(theme) {\n  if (isJSONTheme(theme)) {\n    return [theme.name];\n  }\n  if (typeof theme === \"string\") {\n    return [theme];\n  }\n  return Object.values(theme).map(\n    (theme2) => typeof theme2 === \"string\" ? theme2 : theme2.name\n  );\n}\nfunction replaceLineClass(element) {\n  if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n    const className = element.properties.className.filter((c) => c !== \"line\");\n    element.properties.className = className.length > 0 ? className : void 0;\n    element.properties[\"data-line\"] = \"\";\n  }\n}\nfunction getLineId(lineNumber, meta) {\n  const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n  if (!segments) return null;\n  for (const segment of segments) {\n    const [range, id] = segment.split(\"#\");\n    if (!(range && id)) continue;\n    const match = range.match(/\\{(.*?)\\}/);\n    const capture = match?.[1];\n    if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n      return id;\n    }\n  }\n  return null;\n}\n\n// src/chars/splitElement.ts\nfunction splitElement({\n  elements,\n  elementToWrap,\n  innerString,\n  rightString,\n  leftString,\n  rest,\n  nextElementContinues,\n  index,\n  ignoreChars\n}) {\n  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n    return [elementToWrap, index];\n  }\n  let newIndex = index;\n  const textElement = elementToWrap.children[0];\n  if (isText(textElement)) {\n    textElement.value = innerString;\n  }\n  let rightStr = rightString;\n  const leftStr = leftString;\n  if (rest.length > 0) {\n    rightStr += rest.map((s) => s === \"\" ? innerString : innerString + s).join(\"\");\n  }\n  if (leftStr.length > 0) {\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: leftStr }]\n    });\n  }\n  if (rightStr.length > 0 && !nextElementContinues) {\n    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: rightStr }]\n    });\n  }\n  return [elementToWrap, index + 1];\n}\nfunction nextElementMaybeContinuesChars({\n  elements,\n  nextIndex,\n  remainingPart\n}) {\n  if (remainingPart === \"\") {\n    return false;\n  }\n  const nextNode = elements[nextIndex];\n  const content = getContent(nextNode);\n  if (!content) {\n    return false;\n  }\n  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n  const overlap = findOverlap(content, remainingPart);\n  if (overlap === remainingPart && content.startsWith(remainingPart)) {\n    return true;\n  }\n  if (includesNext) {\n    return nextElementMaybeContinuesChars({\n      elements,\n      nextIndex: nextIndex + 1,\n      remainingPart: remainingPart.replace(content, \"\")\n    });\n  }\n  return false;\n}\nfunction getContent(node) {\n  if (!node) return;\n  return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n  if (b.length === 0) {\n    return \"\";\n  }\n  if (a.endsWith(b)) {\n    return b;\n  }\n  if (a.indexOf(b) >= 0) {\n    return b;\n  }\n  return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n  return s.split(\"\").reverse().join(\"\");\n}\n\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n  const toWrap = [];\n  let charsSoFar = \"\";\n  if (element.children) {\n    const elements = element.children;\n    for (let i = startIndex; i < elements.length; i++) {\n      const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n      if (remaining === \"\") {\n        return toWrap;\n      }\n      const maybeElement = elements[i];\n      if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n      Object.hasOwn(\n        maybeElement.properties ?? {},\n        \"rehype-pretty-code-visited\"\n      )) {\n        continue;\n      }\n      const content = getContent(maybeElement) || \"\";\n      if (content === chars || charsSoFar + content === chars) {\n        toWrap.push({ element: maybeElement, index: i });\n        return toWrap;\n      }\n      if (chars.startsWith(charsSoFar + content)) {\n        if (nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: remaining.replace(content, \"\")\n        })) {\n          toWrap.push({ element: elements[i], index: i });\n          charsSoFar += content;\n          continue;\n        }\n      }\n      const overlap = findOverlap(content, remaining);\n      const partialMatch = overlap && remaining.startsWith(overlap);\n      if (partialMatch) {\n        const nextPart = remaining.replace(overlap, \"\");\n        if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: nextPart\n        })) {\n          continue;\n        }\n        const splitParts = content.split(overlap);\n        const [leftPart, rightPart, ...rest] = splitParts;\n        if (rightPart || leftPart || rest.length > 0) {\n          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n          const nextNodeOverlap = findOverlap(withNextNode, remaining);\n          const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n            const rightString = rightPart.replace(overlap, \"\");\n            const innerString = overlap;\n            const leftString = content.substring(0, splitIndex);\n            const nextElementContinues = nextElementMaybeContinuesChars({\n              elements,\n              nextIndex: i + 1,\n              remainingPart: nextPart\n            });\n            const [newElement, updatedIndex] = splitElement({\n              elements,\n              elementToWrap: elements[i],\n              innerString,\n              rightString,\n              leftString,\n              rest,\n              nextElementContinues,\n              index: i,\n              ignoreChars\n            });\n            charsSoFar += overlap;\n            toWrap.push({\n              element: newElement,\n              index: updatedIndex\n            });\n          }\n        }\n      }\n    }\n  }\n  return toWrap;\n}\n\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n  if (!elementsToWrap || elementsToWrap.length === 0) {\n    return;\n  }\n  const [{ element }] = elementsToWrap;\n  if (ignoreWord) {\n    if (element.properties) {\n      element.properties[\"rehype-pretty-code-visited\"] = \"\";\n    }\n    return;\n  }\n  if (elementsToWrap.length > 1) {\n    parentElement.children.splice(\n      elementsToWrap[0].index,\n      elementsToWrap.length,\n      {\n        type: \"element\",\n        tagName: \"mark\",\n        properties: { \"data-highlighted-chars-mark\": \"\" },\n        children: elementsToWrap.map(({ element: element3 }) => element3)\n      }\n    );\n    const element2 = parentElement.children[elementsToWrap[0].index];\n    if (!isElement(element2)) {\n      return;\n    }\n    const wordStr = element2.children.reduce((acc, node) => {\n      const textElement = isElement(node) ? node.children[0] : null;\n      if (isText(textElement)) {\n        return acc + textElement.value;\n      }\n      return acc;\n    }, \"\");\n    const id = options.idsMap.get(wordStr);\n    element2.properties = element2.properties || {};\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    onVisitHighlightedChars?.(element2, id);\n  } else {\n    const [{ element: element2 }] = elementsToWrap;\n    const textElement = element2.children[0];\n    if (!isText(textElement)) {\n      return;\n    }\n    const id = options.idsMap.get(textElement.value);\n    element2.properties = element2.properties || {};\n    element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    element2.children = [\n      {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          style: element2.properties.style\n        },\n        children: element2.children\n      }\n    ];\n    element2.properties.style = void 0;\n    onVisitHighlightedChars?.(element2, id);\n  }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n  const { ranges = [] } = options;\n  const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n  charsList.forEach((chars, index) => {\n    if (chars && textContent?.includes(chars)) {\n      let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n      let startIndex = 0;\n      while (textContent2.includes(chars)) {\n        const currentCharsRange = ranges[index] || [];\n        const id = `${chars}-${index}`;\n        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n        const elementsToWrap = getElementsToHighlight(\n          element,\n          chars,\n          startIndex,\n          ignoreChars\n        );\n        if (elementsToWrap.length === 0) break;\n        wrapHighlightedChars(\n          element,\n          elementsToWrap,\n          options,\n          ignoreChars,\n          onVisitHighlightedChars\n        );\n        startIndex = Math.max(\n          elementsToWrap[elementsToWrap.length - 1].index - 2,\n          0\n        );\n        textContent2 = element.children.map((childNode) => {\n          const props = isElement(childNode) ? childNode.properties : {};\n          if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n            return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n          }\n        }).join(\"\");\n      }\n    }\n  });\n  element.children.forEach((childNode) => {\n    if (!isElement(childNode)) return;\n    if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n      childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n    }\n  });\n}\n\n// src/index.ts\nfunction apply(element, {\n  tree,\n  lang,\n  title,\n  caption,\n  inline = false,\n  keepBackground = true,\n  grid = true,\n  lineNumbersMaxDigits = 1,\n  theme,\n  onVisitTitle,\n  onVisitCaption\n}) {\n  element.tagName = inline ? \"span\" : \"figure\";\n  element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n  const codeData = element.children[0]?.data;\n  element.children = [tree].flatMap((tree2) => {\n    const pre = tree2.children[0];\n    const themeNames = getThemeNames(theme);\n    const themeNamesString = themeNames.join(\" \");\n    if (!(isElement(pre) && pre.properties)) {\n      return [];\n    }\n    const code = pre.children[0];\n    if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n      const className = pre.properties.className.filter(\n        (c) => c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true)\n      );\n      pre.properties.className = className.length > 0 ? className : void 0;\n    }\n    if (!keepBackground) {\n      pre.properties.style = void 0;\n    }\n    pre.properties[\"data-language\"] = lang;\n    pre.properties[\"data-theme\"] = themeNamesString;\n    if (!(isElement(code) && code.properties)) {\n      return [];\n    }\n    code.properties[\"data-language\"] = lang;\n    code.properties[\"data-theme\"] = themeNamesString;\n    code.data = codeData;\n    if (inline) {\n      if (keepBackground) {\n        code.properties.style = pre.properties.style;\n      }\n      return code;\n    }\n    if (grid) {\n      if (code.properties.style) {\n        code.properties.style += \"display: grid;\";\n      } else {\n        code.properties.style = \"display: grid;\";\n      }\n    }\n    if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n      code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n    }\n    const fragments = [];\n    if (title) {\n      const elementContent = {\n        type: \"element\",\n        tagName: caption ? \"div\" : \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-title\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: title }]\n      };\n      onVisitTitle?.(elementContent);\n      fragments.push(elementContent);\n    }\n    fragments.push(pre);\n    if (caption) {\n      const elementContent = {\n        type: \"element\",\n        tagName: \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-caption\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: caption }]\n      };\n      onVisitCaption?.(elementContent);\n      fragments.push(elementContent);\n    }\n    return fragments;\n  });\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { fragment: true });\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n  const {\n    grid = true,\n    theme = \"github-dark-dimmed\",\n    keepBackground = true,\n    bypassInlineCode = false,\n    defaultLang = \"\",\n    tokensMap = {},\n    filterMetaString = (v) => v,\n    getHighlighter = shiki__WEBPACK_IMPORTED_MODULE_0__.getSingletonHighlighter,\n    transformers,\n    onVisitLine,\n    onVisitHighlightedLine,\n    onVisitHighlightedChars,\n    onVisitTitle,\n    onVisitCaption\n  } = options;\n  const key = JSON.stringify(theme);\n  let cachedHighlighter = globalHighlighterCache.get(key);\n  if (!cachedHighlighter) {\n    cachedHighlighter = getHighlighter({\n      themes: isJSONTheme(theme) || typeof theme === \"string\" ? [theme] : Object.values(theme),\n      langs: [\"plaintext\"]\n    });\n    globalHighlighterCache.set(key, cachedHighlighter);\n  }\n  const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n  const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n  function getOptions(lang, meta) {\n    const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n    const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n    return {\n      lang,\n      meta: { __raw: meta },\n      transformers,\n      defaultColor: typeof theme === \"string\" ? theme : false,\n      ...multipleThemes ? { themes: multipleThemes } : { theme: singleTheme }\n    };\n  }\n  return async (tree) => {\n    const langsToLoad = /* @__PURE__ */ new Set();\n    const highlighter = await cachedHighlighter;\n    if (!highlighter) return;\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent, bypassInlineCode)) {\n        const textElement = element.children[0];\n        if (!isText(textElement)) return;\n        const value = textElement.value;\n        if (!value) return;\n        const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n        if (lang && lang[0] !== \".\") {\n          langsToLoad.add(lang);\n        }\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement)) return;\n        const { lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (lang) {\n          langsToLoad.add(lang);\n        }\n      }\n    });\n    try {\n      await Promise.allSettled(\n        Array.from(langsToLoad).map((lang) => {\n          try {\n            return highlighter.loadLanguage(\n              lang\n            );\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        })\n      );\n    } catch (e) {\n      console.error(e);\n    }\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent, bypassInlineCode)) {\n        const textElement = element.children[0];\n        if (!isText(textElement)) return;\n        const value = textElement.value;\n        if (!value) return;\n        const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n        const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n        textElement.value = strippedValue;\n        const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n        const isLang = lang[0] !== \".\";\n        if (!lang) return;\n        let codeTree;\n        if (isLang) {\n          try {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(lang))\n            );\n          } catch {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\"))\n            );\n          }\n        } else {\n          const themeNames = getThemeNames(theme);\n          const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n          const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n          const colorsByTheme = themeNames.map(\n            (name) => name ? highlighter.getTheme(name).settings.find(\n              ({ scope }) => scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1))\n            )?.settings.foreground ?? \"inherit\" : \"inherit\"\n          );\n          if (isMultiTheme && themeKeys) {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"${themeKeys.map((key2, i) => `--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`\n            );\n          } else {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`\n            );\n          }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n        apply(element, {\n          tree: codeTree,\n          lang: isLang ? lang : \".token\",\n          inline: true,\n          keepBackground,\n          theme\n        });\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement)) return;\n        const textElement = codeElement.children[0];\n        const { title, caption, meta, lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (!lang || lang === \"math\") return;\n        const lineNumbers = [];\n        if (meta) {\n          const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n          for (const match of matches) {\n            if (match[1]) {\n              lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n            }\n          }\n        }\n        let lineNumbersMaxDigits = 0;\n        const lineIdMap = /* @__PURE__ */ new Map();\n        const charsList = [];\n        const charsListNumbers = [];\n        const charsListIdMap = /* @__PURE__ */ new Map();\n        const charsMatches = meta ? [\n          ...meta.matchAll(\n            /(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g\n          )\n        ] : void 0;\n        lineNumbers.forEach((lineNumber) => {\n          const id = getLineId(lineNumber, meta);\n          id && lineIdMap.set(lineNumber, id);\n        });\n        if (Array.isArray(charsMatches)) {\n          charsMatches.forEach((name) => {\n            const { chars, charsIdAndOrRange } = name.groups;\n            charsList.push(chars);\n            if (charsIdAndOrRange === \"\") {\n              charsListNumbers.push([]);\n            } else {\n              const [range, id] = charsIdAndOrRange.split(\"#\");\n              range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n              id && charsListIdMap.set(chars, id);\n            }\n          });\n        }\n        if (!isText(textElement)) return;\n        const strippedValue = textElement.value.replace(/\\n$/, \"\");\n        let codeTree;\n        try {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(strippedValue, getOptions(lang, meta))\n          );\n        } catch {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(\n              strippedValue,\n              getOptions(\"plaintext\", meta)\n            )\n          );\n        }\n        let lineCounter = 0;\n        const charsHighlighterOptions = {\n          ranges: charsListNumbers,\n          idsMap: charsListIdMap,\n          counterMap: /* @__PURE__ */ new Map()\n        };\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2) => {\n          if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n            if (element2.properties) {\n              element2.properties[\"data-line-numbers\"] = \"\";\n            }\n            const lineNumbersStartAtMatch = reverseString(meta).match(\n              /(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/\n            );\n            const startNumberString = lineNumbersStartAtMatch?.[1];\n            if (startNumberString) {\n              const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n              lineNumbersMaxDigits = startAt;\n              if (element2.properties) {\n                element2.properties.style = `counter-set: line ${startAt};`;\n              }\n            }\n          }\n          if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n            if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n              element2.children = [{ type: \"text\", value: \" \" }];\n            }\n            replaceLineClass(element2);\n            onVisitLine?.(element2);\n            lineCounter++;\n            if (lineNumbers.includes(lineCounter)) {\n              element2.properties[\"data-highlighted-line\"] = \"\";\n              const lineId = lineIdMap.get(lineCounter);\n              if (lineId) {\n                element2.properties[\"data-highlighted-line-id\"] = lineId;\n              }\n              onVisitHighlightedLine?.(element2, lineId);\n            }\n            charsHighlighter(\n              element2,\n              charsList,\n              charsHighlighterOptions,\n              onVisitHighlightedChars\n            );\n            lineNumbersMaxDigits++;\n          }\n        });\n        apply(element, {\n          tree: codeTree,\n          lang,\n          title,\n          caption,\n          keepBackground,\n          grid,\n          lineNumbersMaxDigits,\n          theme,\n          onVisitTitle,\n          onVisitCaption\n        });\n      }\n    });\n  };\n}\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDUDtBQUNNO0FBQ0E7QUFDYjtBQUNLOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBLG1CQUFtQixnREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiw4QkFBOEI7QUFDakQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiwrQkFBK0I7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQsd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsc0JBQXNCLDZEQUFRO0FBQzlCO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0sR0FBRyxNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQVE7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxRQUFRO0FBQ1IsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixnREFBTyxPQUFPLG9EQUFXLElBQUksZ0JBQWdCO0FBQzlEO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHFCQUFxQiwwREFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUIsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUksdURBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUMsZ0VBQWdFLGFBQWEsNkJBQTZCLGFBQWE7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNDQUFzQyxLQUFLLEdBQUcsaUJBQWlCLFVBQVUsR0FBRyxJQUFJLGNBQWM7QUFDdkk7QUFDQSxZQUFZO0FBQ1o7QUFDQSwrQ0FBK0MsaUJBQWlCLElBQUksY0FBYztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxnREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2Q0FBNkMsZ0RBQVk7QUFDekQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2REFBUTtBQUNoQyxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2tob2ktam91cm5leS1ibG9nLy4vbm9kZV9tb2R1bGVzL3JlaHlwZS1wcmV0dHktY29kZS9kaXN0L2luZGV4LmpzPzM1MTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIgfSBmcm9tICdzaGlraSc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQnO1xuaW1wb3J0IHsgdG9TdHJpbmcgfSBmcm9tICdoYXN0LXV0aWwtdG8tc3RyaW5nJztcbmltcG9ydCByYW5nZVBhcnNlcjIgZnJvbSAncGFyc2UtbnVtZXJpYy1yYW5nZSc7XG5pbXBvcnQgeyB1bmlmaWVkIH0gZnJvbSAndW5pZmllZCc7XG5pbXBvcnQgcmVoeXBlUGFyc2UgZnJvbSAncmVoeXBlLXBhcnNlJztcblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBpc0pTT05UaGVtZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyBPYmplY3QuaGFzT3duKHZhbHVlLCBcInRva2VuQ29sb3JzXCIpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUudHlwZSA9PT0gXCJlbGVtZW50XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS50eXBlID09PSBcInRleHRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCwgYnlwYXNzID0gZmFsc2UpIHtcbiAgaWYgKGJ5cGFzcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcImNvZGVcIiAmJiBpc0VsZW1lbnQocGFyZW50KSAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJwcmVcIiB8fCBlbGVtZW50LnRhZ05hbWUgPT09IFwiaW5saW5lQ29kZVwiO1xufVxuZnVuY3Rpb24gaXNCbG9ja0NvZGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcInByZVwiICYmIEFycmF5LmlzQXJyYXkoZWxlbWVudC5jaGlsZHJlbikgJiYgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgaXNFbGVtZW50KGVsZW1lbnQuY2hpbGRyZW5bMF0pICYmIGVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gXCJjb2RlXCI7XG59XG5mdW5jdGlvbiBnZXRJbmxpbmVDb2RlTGFuZyhtZXRhLCBkZWZhdWx0RmFsbGJhY2tMYW5nKSB7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gXCJcXDBcIjtcbiAgbGV0IHRlbXAgPSBtZXRhLnJlcGxhY2UoL1xcXFxcXFxcL2csIHBsYWNlaG9sZGVyKTtcbiAgdGVtcCA9IHRlbXAucmVwbGFjZSgvXFxcXCh7OlthLXpBLVouLV0rfSkkLywgXCIkMVwiKTtcbiAgY29uc3QgbGFuZyA9IHRlbXAubWF0Y2goL3s6KFthLXpBLVouLV0rKX0kLyk/LlsxXTtcbiAgcmV0dXJuIGxhbmc/LnJlcGxhY2UobmV3IFJlZ0V4cChwbGFjZWhvbGRlciwgXCJnXCIpLCBcIlxcXFxcIikgfHwgZGVmYXVsdEZhbGxiYWNrTGFuZztcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tNZXRhU3RyaW5nKGVsZW1lbnQsIGZpbHRlciwgZGVmYXVsdEZhbGxiYWNrKSB7XG4gIGxldCBtZXRhID0gZmlsdGVyKFxuICAgIGVsZW1lbnQuZGF0YT8ubWV0YSA/PyBlbGVtZW50LnByb3BlcnRpZXM/Lm1ldGFzdHJpbmcgPz8gXCJcIlxuICApO1xuICBjb25zdCB0aXRsZU1hdGNoID0gbWV0YS5tYXRjaCgvdGl0bGU9XCIoW15cIl0qKVwiLyk7XG4gIGNvbnN0IHRpdGxlID0gdGl0bGVNYXRjaD8uWzFdID8/IG51bGw7XG4gIG1ldGEgPSBtZXRhLnJlcGxhY2UodGl0bGVNYXRjaD8uWzBdID8/IFwiXCIsIFwiXCIpO1xuICBjb25zdCBjYXB0aW9uTWF0Y2ggPSBtZXRhLm1hdGNoKC9jYXB0aW9uPVwiKFteXCJdKilcIi8pO1xuICBjb25zdCBjYXB0aW9uID0gY2FwdGlvbk1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgbWV0YSA9IG1ldGEucmVwbGFjZShjYXB0aW9uTWF0Y2g/LlswXSA/PyBcIlwiLCBcIlwiKTtcbiAgbGV0IGxhbmcgPSBkZWZhdWx0RmFsbGJhY2s7XG4gIGlmIChlbGVtZW50LnByb3BlcnRpZXMgJiYgQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiB0eXBlb2YgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnN0YXJ0c1dpdGgoXCJsYW5ndWFnZS1cIikpIHtcbiAgICBsYW5nID0gZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXS5yZXBsYWNlKFwibGFuZ3VhZ2UtXCIsIFwiXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGl0bGUsXG4gICAgY2FwdGlvbixcbiAgICBsYW5nLFxuICAgIG1ldGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRoZW1lTmFtZXModGhlbWUpIHtcbiAgaWYgKGlzSlNPTlRoZW1lKHRoZW1lKSkge1xuICAgIHJldHVybiBbdGhlbWUubmFtZV07XG4gIH1cbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbdGhlbWVdO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHRoZW1lKS5tYXAoXG4gICAgKHRoZW1lMikgPT4gdHlwZW9mIHRoZW1lMiA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lMiA6IHRoZW1lMi5uYW1lXG4gICk7XG59XG5mdW5jdGlvbiByZXBsYWNlTGluZUNsYXNzKGVsZW1lbnQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudC5wcm9wZXJ0aWVzPy5jbGFzc05hbWUpICYmIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUuaW5jbHVkZXMoXCJsaW5lXCIpKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5maWx0ZXIoKGMpID0+IGMgIT09IFwibGluZVwiKTtcbiAgICBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiB2b2lkIDA7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lXCJdID0gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGluZUlkKGxpbmVOdW1iZXIsIG1ldGEpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBtZXRhLm1hdGNoKC9cXHtbXn1dK1xcfSNbYS16QS1aMC05XSsvZyk7XG4gIGlmICghc2VnbWVudHMpIHJldHVybiBudWxsO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCBbcmFuZ2UsIGlkXSA9IHNlZ21lbnQuc3BsaXQoXCIjXCIpO1xuICAgIGlmICghKHJhbmdlICYmIGlkKSkgY29udGludWU7XG4gICAgY29uc3QgbWF0Y2ggPSByYW5nZS5tYXRjaCgvXFx7KC4qPylcXH0vKTtcbiAgICBjb25zdCBjYXB0dXJlID0gbWF0Y2g/LlsxXTtcbiAgICBpZiAoY2FwdHVyZSAmJiByYW5nZVBhcnNlcjIoY2FwdHVyZSkuaW5jbHVkZXMobGluZU51bWJlcikpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy9jaGFycy9zcGxpdEVsZW1lbnQudHNcbmZ1bmN0aW9uIHNwbGl0RWxlbWVudCh7XG4gIGVsZW1lbnRzLFxuICBlbGVtZW50VG9XcmFwLFxuICBpbm5lclN0cmluZyxcbiAgcmlnaHRTdHJpbmcsXG4gIGxlZnRTdHJpbmcsXG4gIHJlc3QsXG4gIG5leHRFbGVtZW50Q29udGludWVzLFxuICBpbmRleCxcbiAgaWdub3JlQ2hhcnNcbn0pIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50VG9XcmFwKSAmJiBlbGVtZW50VG9XcmFwLmNoaWxkcmVuPy5bMF0/LnR5cGUgIT09IFwidGV4dFwiIHx8IGlnbm9yZUNoYXJzKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50VG9XcmFwLCBpbmRleF07XG4gIH1cbiAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG4gIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudFRvV3JhcC5jaGlsZHJlblswXTtcbiAgaWYgKGlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICB0ZXh0RWxlbWVudC52YWx1ZSA9IGlubmVyU3RyaW5nO1xuICB9XG4gIGxldCByaWdodFN0ciA9IHJpZ2h0U3RyaW5nO1xuICBjb25zdCBsZWZ0U3RyID0gbGVmdFN0cmluZztcbiAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIHJpZ2h0U3RyICs9IHJlc3QubWFwKChzKSA9PiBzID09PSBcIlwiID8gaW5uZXJTdHJpbmcgOiBpbm5lclN0cmluZyArIHMpLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKGxlZnRTdHIubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShuZXdJbmRleCwgMCwge1xuICAgICAgLi4uZWxlbWVudFRvV3JhcCxcbiAgICAgIHByb3BlcnRpZXM6IHsgLi4uZWxlbWVudFRvV3JhcC5wcm9wZXJ0aWVzIH0sXG4gICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBsZWZ0U3RyIH1dXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJpZ2h0U3RyLmxlbmd0aCA+IDAgJiYgIW5leHRFbGVtZW50Q29udGludWVzKSB7XG4gICAgbmV3SW5kZXggPSBsZWZ0U3RyLmxlbmd0aCA+IDAgPyBuZXdJbmRleCArIDIgOiBuZXdJbmRleCArIDE7XG4gICAgZWxlbWVudHMuc3BsaWNlKG5ld0luZGV4LCAwLCB7XG4gICAgICAuLi5lbGVtZW50VG9XcmFwLFxuICAgICAgcHJvcGVydGllczogeyAuLi5lbGVtZW50VG9XcmFwLnByb3BlcnRpZXMgfSxcbiAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHJpZ2h0U3RyIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtlbGVtZW50VG9XcmFwLCBpbmRleCArIDFdO1xufVxuZnVuY3Rpb24gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgZWxlbWVudHMsXG4gIG5leHRJbmRleCxcbiAgcmVtYWluaW5nUGFydFxufSkge1xuICBpZiAocmVtYWluaW5nUGFydCA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBuZXh0Tm9kZSA9IGVsZW1lbnRzW25leHRJbmRleF07XG4gIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KG5leHROb2RlKTtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzTmV4dCA9IGNvbnRlbnQuc3RhcnRzV2l0aChyZW1haW5pbmdQYXJ0KSB8fCByZW1haW5pbmdQYXJ0LnN0YXJ0c1dpdGgoY29udGVudCk7XG4gIGNvbnN0IG92ZXJsYXAgPSBmaW5kT3ZlcmxhcChjb250ZW50LCByZW1haW5pbmdQYXJ0KTtcbiAgaWYgKG92ZXJsYXAgPT09IHJlbWFpbmluZ1BhcnQgJiYgY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGluY2x1ZGVzTmV4dCkge1xuICAgIHJldHVybiBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgZWxlbWVudHMsXG4gICAgICBuZXh0SW5kZXg6IG5leHRJbmRleCArIDEsXG4gICAgICByZW1haW5pbmdQYXJ0OiByZW1haW5pbmdQYXJ0LnJlcGxhY2UoY29udGVudCwgXCJcIilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50KG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIHJldHVybiB0b1N0cmluZyhub2RlKTtcbn1cbmZ1bmN0aW9uIGZpbmRPdmVybGFwKGEsIGIpIHtcbiAgaWYgKGIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKGEuZW5kc1dpdGgoYikpIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBpZiAoYS5pbmRleE9mKGIpID49IDApIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICByZXR1cm4gZmluZE92ZXJsYXAoYSwgYi5zdWJzdHJpbmcoMCwgYi5sZW5ndGggLSAxKSk7XG59XG5mdW5jdGlvbiByZXZlcnNlU3RyaW5nKHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy9jaGFycy9nZXRFbGVtZW50c1RvSGlnaGxpZ2h0LnRzXG5mdW5jdGlvbiBnZXRFbGVtZW50c1RvSGlnaGxpZ2h0KGVsZW1lbnQsIGNoYXJzLCBzdGFydEluZGV4ID0gMCwgaWdub3JlQ2hhcnMgPSBmYWxzZSkge1xuICBjb25zdCB0b1dyYXAgPSBbXTtcbiAgbGV0IGNoYXJzU29GYXIgPSBcIlwiO1xuICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBjaGFyc1NvRmFyID8gY2hhcnMucmVwbGFjZShjaGFyc1NvRmFyLCBcIlwiKSA6IGNoYXJzO1xuICAgICAgaWYgKHJlbWFpbmluZyA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gdG9XcmFwO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF5YmVFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoIW1heWJlRWxlbWVudCB8fCBtYXliZUVsZW1lbnQudHlwZSAhPT0gXCJlbGVtZW50XCIgfHwgLy8gaWdub3JlIGFueSBwcmV2aW91c2x5IG1hdGNoZWQgY2hhcnMgd2l0aGluXG4gICAgICBPYmplY3QuaGFzT3duKFxuICAgICAgICBtYXliZUVsZW1lbnQucHJvcGVydGllcyA/PyB7fSxcbiAgICAgICAgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXG4gICAgICApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobWF5YmVFbGVtZW50KSB8fCBcIlwiO1xuICAgICAgaWYgKGNvbnRlbnQgPT09IGNoYXJzIHx8IGNoYXJzU29GYXIgKyBjb250ZW50ID09PSBjaGFycykge1xuICAgICAgICB0b1dyYXAucHVzaCh7IGVsZW1lbnQ6IG1heWJlRWxlbWVudCwgaW5kZXg6IGkgfSk7XG4gICAgICAgIHJldHVybiB0b1dyYXA7XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnMuc3RhcnRzV2l0aChjaGFyc1NvRmFyICsgY29udGVudCkpIHtcbiAgICAgICAgaWYgKG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICByZW1haW5pbmdQYXJ0OiByZW1haW5pbmcucmVwbGFjZShjb250ZW50LCBcIlwiKVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHRvV3JhcC5wdXNoKHsgZWxlbWVudDogZWxlbWVudHNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICAgIGNoYXJzU29GYXIgKz0gY29udGVudDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZyk7XG4gICAgICBjb25zdCBwYXJ0aWFsTWF0Y2ggPSBvdmVybGFwICYmIHJlbWFpbmluZy5zdGFydHNXaXRoKG92ZXJsYXApO1xuICAgICAgaWYgKHBhcnRpYWxNYXRjaCkge1xuICAgICAgICBjb25zdCBuZXh0UGFydCA9IHJlbWFpbmluZy5yZXBsYWNlKG92ZXJsYXAsIFwiXCIpO1xuICAgICAgICBpZiAobmV4dFBhcnQgIT09IFwiXCIgJiYgZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pICYmICFuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgcmVtYWluaW5nUGFydDogbmV4dFBhcnRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdFBhcnRzID0gY29udGVudC5zcGxpdChvdmVybGFwKTtcbiAgICAgICAgY29uc3QgW2xlZnRQYXJ0LCByaWdodFBhcnQsIC4uLnJlc3RdID0gc3BsaXRQYXJ0cztcbiAgICAgICAgaWYgKHJpZ2h0UGFydCB8fCBsZWZ0UGFydCB8fCByZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCB3aXRoTmV4dE5vZGUgPSBjb250ZW50ICsgKGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA/IGdldENvbnRlbnQoZWxlbWVudHNbaSArIDFdKSA6IFwiXCIpO1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlT3ZlcmxhcCA9IGZpbmRPdmVybGFwKHdpdGhOZXh0Tm9kZSwgcmVtYWluaW5nKTtcbiAgICAgICAgICBjb25zdCBzcGxpdEluZGV4ID0gd2l0aE5leHROb2RlLmluZGV4T2YobmV4dE5vZGVPdmVybGFwKTtcbiAgICAgICAgICBpZiAoY2hhcnMuZW5kc1dpdGgob3ZlcmxhcCkgfHwgY2hhcnMuc3RhcnRzV2l0aChvdmVybGFwKSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRTdHJpbmcgPSByaWdodFBhcnQucmVwbGFjZShvdmVybGFwLCBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyU3RyaW5nID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRTdHJpbmcgPSBjb250ZW50LnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50Q29udGludWVzID0gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAgIG5leHRJbmRleDogaSArIDEsXG4gICAgICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IG5leHRQYXJ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IFtuZXdFbGVtZW50LCB1cGRhdGVkSW5kZXhdID0gc3BsaXRFbGVtZW50KHtcbiAgICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAgIGVsZW1lbnRUb1dyYXA6IGVsZW1lbnRzW2ldLFxuICAgICAgICAgICAgICBpbm5lclN0cmluZyxcbiAgICAgICAgICAgICAgcmlnaHRTdHJpbmcsXG4gICAgICAgICAgICAgIGxlZnRTdHJpbmcsXG4gICAgICAgICAgICAgIHJlc3QsXG4gICAgICAgICAgICAgIG5leHRFbGVtZW50Q29udGludWVzLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgaWdub3JlQ2hhcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hhcnNTb0ZhciArPSBvdmVybGFwO1xuICAgICAgICAgICAgdG9XcmFwLnB1c2goe1xuICAgICAgICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICAgICAgICBpbmRleDogdXBkYXRlZEluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvV3JhcDtcbn1cblxuLy8gc3JjL2NoYXJzL3dyYXBIaWdobGlnaHRlZENoYXJzLnRzXG5mdW5jdGlvbiB3cmFwSGlnaGxpZ2h0ZWRDaGFycyhwYXJlbnRFbGVtZW50LCBlbGVtZW50c1RvV3JhcCwgb3B0aW9ucywgaWdub3JlV29yZCwgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMpIHtcbiAgaWYgKCFlbGVtZW50c1RvV3JhcCB8fCBlbGVtZW50c1RvV3JhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW3sgZWxlbWVudCB9XSA9IGVsZW1lbnRzVG9XcmFwO1xuICBpZiAoaWdub3JlV29yZCkge1xuICAgIGlmIChlbGVtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgIGVsZW1lbnQucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50c1RvV3JhcC5sZW5ndGggPiAxKSB7XG4gICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5zcGxpY2UoXG4gICAgICBlbGVtZW50c1RvV3JhcFswXS5pbmRleCxcbiAgICAgIGVsZW1lbnRzVG9XcmFwLmxlbmd0aCxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwibWFya1wiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7IFwiZGF0YS1oaWdobGlnaHRlZC1jaGFycy1tYXJrXCI6IFwiXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IGVsZW1lbnRzVG9XcmFwLm1hcCgoeyBlbGVtZW50OiBlbGVtZW50MyB9KSA9PiBlbGVtZW50MylcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbltlbGVtZW50c1RvV3JhcFswXS5pbmRleF07XG4gICAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdvcmRTdHIgPSBlbGVtZW50Mi5jaGlsZHJlbi5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBpc0VsZW1lbnQobm9kZSkgPyBub2RlLmNoaWxkcmVuWzBdIDogbnVsbDtcbiAgICAgIGlmIChpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgXCJcIik7XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLmlkc01hcC5nZXQod29yZFN0cik7XG4gICAgZWxlbWVudDIucHJvcGVydGllcyA9IGVsZW1lbnQyLnByb3BlcnRpZXMgfHwge307XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnNcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWNoYXJzLWlkXCJdID0gaWQ7XG4gICAgZWxlbWVudDIudGFnTmFtZSA9IFwibWFya1wiO1xuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzPy4oZWxlbWVudDIsIGlkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbeyBlbGVtZW50OiBlbGVtZW50MiB9XSA9IGVsZW1lbnRzVG9XcmFwO1xuICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudDIuY2hpbGRyZW5bMF07XG4gICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5pZHNNYXAuZ2V0KHRleHRFbGVtZW50LnZhbHVlKTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzID0gZWxlbWVudDIucHJvcGVydGllcyB8fCB7fTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzXCJdID0gXCJcIjtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1jaGFycy1pZFwiXSA9IGlkO1xuICAgIGVsZW1lbnQyLnRhZ05hbWUgPSBcIm1hcmtcIjtcbiAgICBlbGVtZW50Mi5jaGlsZHJlbiA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgc3R5bGU6IGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGVcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGVsZW1lbnQyLmNoaWxkcmVuXG4gICAgICB9XG4gICAgXTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlID0gdm9pZCAwO1xuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzPy4oZWxlbWVudDIsIGlkKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hhcnNIaWdobGlnaHRlcihlbGVtZW50LCBjaGFyc0xpc3QsIG9wdGlvbnMsIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzKSB7XG4gIGNvbnN0IHsgcmFuZ2VzID0gW10gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gdG9TdHJpbmcoZWxlbWVudCk7XG4gIGNoYXJzTGlzdC5mb3JFYWNoKChjaGFycywgaW5kZXgpID0+IHtcbiAgICBpZiAoY2hhcnMgJiYgdGV4dENvbnRlbnQ/LmluY2x1ZGVzKGNoYXJzKSkge1xuICAgICAgbGV0IHRleHRDb250ZW50MiA9IHRvU3RyaW5nKGVsZW1lbnQpO1xuICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKHRleHRDb250ZW50Mi5pbmNsdWRlcyhjaGFycykpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXJzUmFuZ2UgPSByYW5nZXNbaW5kZXhdIHx8IFtdO1xuICAgICAgICBjb25zdCBpZCA9IGAke2NoYXJzfS0ke2luZGV4fWA7XG4gICAgICAgIG9wdGlvbnMuY291bnRlck1hcC5zZXQoaWQsIChvcHRpb25zLmNvdW50ZXJNYXAuZ2V0KGlkKSB8fCAwKSArIDEpO1xuICAgICAgICBjb25zdCBpZ25vcmVDaGFycyA9IGN1cnJlbnRDaGFyc1JhbmdlLmxlbmd0aCA+IDAgJiYgIWN1cnJlbnRDaGFyc1JhbmdlLmluY2x1ZGVzKG9wdGlvbnMuY291bnRlck1hcC5nZXQoaWQpID8/IC0xKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb1dyYXAgPSBnZXRFbGVtZW50c1RvSGlnaGxpZ2h0KFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgY2hhcnMsXG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBpZ25vcmVDaGFyc1xuICAgICAgICApO1xuICAgICAgICBpZiAoZWxlbWVudHNUb1dyYXAubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgd3JhcEhpZ2hsaWdodGVkQ2hhcnMoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGlnbm9yZUNoYXJzLFxuICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICk7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heChcbiAgICAgICAgICBlbGVtZW50c1RvV3JhcFtlbGVtZW50c1RvV3JhcC5sZW5ndGggLSAxXS5pbmRleCAtIDIsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBlbGVtZW50LmNoaWxkcmVuLm1hcCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvcHMgPSBpc0VsZW1lbnQoY2hpbGROb2RlKSA/IGNoaWxkTm9kZS5wcm9wZXJ0aWVzIDoge307XG4gICAgICAgICAgaWYgKHByb3BzICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCIpICYmICFPYmplY3QuaGFzT3duKHByb3BzLCBcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnMtbWFya1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgaWYgKCFpc0VsZW1lbnQoY2hpbGROb2RlKSkgcmV0dXJuO1xuICAgIGlmIChPYmplY3QuaGFzT3duKGNoaWxkTm9kZS5wcm9wZXJ0aWVzLCBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCIpKSB7XG4gICAgICBjaGlsZE5vZGUucHJvcGVydGllc1tcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJdID0gdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gYXBwbHkoZWxlbWVudCwge1xuICB0cmVlLFxuICBsYW5nLFxuICB0aXRsZSxcbiAgY2FwdGlvbixcbiAgaW5saW5lID0gZmFsc2UsXG4gIGtlZXBCYWNrZ3JvdW5kID0gdHJ1ZSxcbiAgZ3JpZCA9IHRydWUsXG4gIGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gMSxcbiAgdGhlbWUsXG4gIG9uVmlzaXRUaXRsZSxcbiAgb25WaXNpdENhcHRpb25cbn0pIHtcbiAgZWxlbWVudC50YWdOYW1lID0gaW5saW5lID8gXCJzcGFuXCIgOiBcImZpZ3VyZVwiO1xuICBlbGVtZW50LnByb3BlcnRpZXNbXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS1maWd1cmVcIl0gPSBcIlwiO1xuICBjb25zdCBjb2RlRGF0YSA9IGVsZW1lbnQuY2hpbGRyZW5bMF0/LmRhdGE7XG4gIGVsZW1lbnQuY2hpbGRyZW4gPSBbdHJlZV0uZmxhdE1hcCgodHJlZTIpID0+IHtcbiAgICBjb25zdCBwcmUgPSB0cmVlMi5jaGlsZHJlblswXTtcbiAgICBjb25zdCB0aGVtZU5hbWVzID0gZ2V0VGhlbWVOYW1lcyh0aGVtZSk7XG4gICAgY29uc3QgdGhlbWVOYW1lc1N0cmluZyA9IHRoZW1lTmFtZXMuam9pbihcIiBcIik7XG4gICAgaWYgKCEoaXNFbGVtZW50KHByZSkgJiYgcHJlLnByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBwcmUuY2hpbGRyZW5bMF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuaW5jbHVkZXMoXCJzaGlraVwiKSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcihcbiAgICAgICAgKGMpID0+IGMgIT09IFwic2hpa2lcIiAmJiBjICE9PSBcInNoaWtpLXRoZW1lc1wiICYmICh0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiA/ICF0aGVtZU5hbWVzLmluY2x1ZGVzKGMpIDogdHJ1ZSlcbiAgICAgICk7XG4gICAgICBwcmUucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCFrZWVwQmFja2dyb3VuZCkge1xuICAgICAgcHJlLnByb3BlcnRpZXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHByZS5wcm9wZXJ0aWVzW1wiZGF0YS1sYW5ndWFnZVwiXSA9IGxhbmc7XG4gICAgcHJlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBpZiAoIShpc0VsZW1lbnQoY29kZSkgJiYgY29kZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxhbmd1YWdlXCJdID0gbGFuZztcbiAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLXRoZW1lXCJdID0gdGhlbWVOYW1lc1N0cmluZztcbiAgICBjb2RlLmRhdGEgPSBjb2RlRGF0YTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBpZiAoa2VlcEJhY2tncm91bmQpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgaWYgKGdyaWQpIHtcbiAgICAgIGlmIChjb2RlLnByb3BlcnRpZXMuc3R5bGUpIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlICs9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSA9IFwiZGlzcGxheTogZ3JpZDtcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY29kZS5wcm9wZXJ0aWVzLCBcImRhdGEtbGluZS1udW1iZXJzXCIpKSB7XG4gICAgICBjb2RlLnByb3BlcnRpZXNbXCJkYXRhLWxpbmUtbnVtYmVycy1tYXgtZGlnaXRzXCJdID0gbGluZU51bWJlcnNNYXhEaWdpdHMudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBjYXB0aW9uID8gXCJkaXZcIiA6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS10aXRsZVwiOiBcIlwiLFxuICAgICAgICAgIFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLFxuICAgICAgICAgIFwiZGF0YS10aGVtZVwiOiB0aGVtZU5hbWVzU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRpdGxlIH1dXG4gICAgICB9O1xuICAgICAgb25WaXNpdFRpdGxlPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICBmcmFnbWVudHMucHVzaChwcmUpO1xuICAgIGlmIChjYXB0aW9uKSB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwiZmlnY2FwdGlvblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgXCJkYXRhLXJlaHlwZS1wcmV0dHktY29kZS1jYXB0aW9uXCI6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcsXG4gICAgICAgICAgXCJkYXRhLXRoZW1lXCI6IHRoZW1lTmFtZXNTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogY2FwdGlvbiB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRDYXB0aW9uPy4oZWxlbWVudENvbnRlbnQpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZWxlbWVudENvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xuICB9KTtcbn1cbnZhciBnbG9iYWxIaWdobGlnaHRlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBoYXN0UGFyc2VyID0gdW5pZmllZCgpLnVzZShyZWh5cGVQYXJzZSwgeyBmcmFnbWVudDogdHJ1ZSB9KTtcbnZhciBzcmNfZGVmYXVsdCA9IHJlaHlwZVByZXR0eUNvZGU7XG5mdW5jdGlvbiByZWh5cGVQcmV0dHlDb2RlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZ3JpZCA9IHRydWUsXG4gICAgdGhlbWUgPSBcImdpdGh1Yi1kYXJrLWRpbW1lZFwiLFxuICAgIGtlZXBCYWNrZ3JvdW5kID0gdHJ1ZSxcbiAgICBieXBhc3NJbmxpbmVDb2RlID0gZmFsc2UsXG4gICAgZGVmYXVsdExhbmcgPSBcIlwiLFxuICAgIHRva2Vuc01hcCA9IHt9LFxuICAgIGZpbHRlck1ldGFTdHJpbmcgPSAodikgPT4gdixcbiAgICBnZXRIaWdobGlnaHRlciA9IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyLFxuICAgIHRyYW5zZm9ybWVycyxcbiAgICBvblZpc2l0TGluZSxcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzLFxuICAgIG9uVmlzaXRUaXRsZSxcbiAgICBvblZpc2l0Q2FwdGlvblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkodGhlbWUpO1xuICBsZXQgY2FjaGVkSGlnaGxpZ2h0ZXIgPSBnbG9iYWxIaWdobGlnaHRlckNhY2hlLmdldChrZXkpO1xuICBpZiAoIWNhY2hlZEhpZ2hsaWdodGVyKSB7XG4gICAgY2FjaGVkSGlnaGxpZ2h0ZXIgPSBnZXRIaWdobGlnaHRlcih7XG4gICAgICB0aGVtZXM6IGlzSlNPTlRoZW1lKHRoZW1lKSB8fCB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyBbdGhlbWVdIDogT2JqZWN0LnZhbHVlcyh0aGVtZSksXG4gICAgICBsYW5nczogW1wicGxhaW50ZXh0XCJdXG4gICAgfSk7XG4gICAgZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZS5zZXQoa2V5LCBjYWNoZWRIaWdobGlnaHRlcik7XG4gIH1cbiAgY29uc3QgZGVmYXVsdENvZGVCbG9ja0xhbmcgPSB0eXBlb2YgZGVmYXVsdExhbmcgPT09IFwic3RyaW5nXCIgPyBkZWZhdWx0TGFuZyA6IGRlZmF1bHRMYW5nLmJsb2NrIHx8IFwiXCI7XG4gIGNvbnN0IGRlZmF1bHRJbmxpbmVDb2RlTGFuZyA9IHR5cGVvZiBkZWZhdWx0TGFuZyA9PT0gXCJzdHJpbmdcIiA/IGRlZmF1bHRMYW5nIDogZGVmYXVsdExhbmcuaW5saW5lIHx8IFwiXCI7XG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMobGFuZywgbWV0YSkge1xuICAgIGNvbnN0IG11bHRpcGxlVGhlbWVzID0gIWlzSlNPTlRoZW1lKHRoZW1lKSAmJiB0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgPyB0aGVtZSA6IG51bGw7XG4gICAgY29uc3Qgc2luZ2xlVGhlbWUgPSBpc0pTT05UaGVtZSh0aGVtZSkgfHwgdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBsYW5nLFxuICAgICAgbWV0YTogeyBfX3JhdzogbWV0YSB9LFxuICAgICAgdHJhbnNmb3JtZXJzLFxuICAgICAgZGVmYXVsdENvbG9yOiB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IGZhbHNlLFxuICAgICAgLi4ubXVsdGlwbGVUaGVtZXMgPyB7IHRoZW1lczogbXVsdGlwbGVUaGVtZXMgfSA6IHsgdGhlbWU6IHNpbmdsZVRoZW1lIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhc3luYyAodHJlZSkgPT4ge1xuICAgIGNvbnN0IGxhbmdzVG9Mb2FkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBoaWdobGlnaHRlciA9IGF3YWl0IGNhY2hlZEhpZ2hsaWdodGVyO1xuICAgIGlmICghaGlnaGxpZ2h0ZXIpIHJldHVybjtcbiAgICB2aXNpdCh0cmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQsIF8sIHBhcmVudCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQsIGJ5cGFzc0lubGluZUNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFuZyA9IGdldElubGluZUNvZGVMYW5nKHZhbHVlLCBkZWZhdWx0SW5saW5lQ29kZUxhbmcpO1xuICAgICAgICBpZiAobGFuZyAmJiBsYW5nWzBdICE9PSBcIi5cIikge1xuICAgICAgICAgIGxhbmdzVG9Mb2FkLmFkZChsYW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbGFuZyB9ID0gcGFyc2VCbG9ja01ldGFTdHJpbmcoXG4gICAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgICAgZmlsdGVyTWV0YVN0cmluZyxcbiAgICAgICAgICBkZWZhdWx0Q29kZUJsb2NrTGFuZ1xuICAgICAgICApO1xuICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgIGxhbmdzVG9Mb2FkLmFkZChsYW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXG4gICAgICAgIEFycmF5LmZyb20obGFuZ3NUb0xvYWQpLm1hcCgobGFuZykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZXIubG9hZExhbmd1YWdlKFxuICAgICAgICAgICAgICBsYW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHZpc2l0KHRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudCwgXywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCwgYnlwYXNzSW5saW5lQ29kZSkpIHtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBrZWVwTGFuZ1BhcnQgPSAvXFxcXHs6W2EtekEtWi4tXSt9JC8udGVzdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSBrZWVwTGFuZ1BhcnQgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcKHs6W2EtekEtWi4tXSt9KSQvLCBcIiQxXCIpIDogdmFsdWUucmVwbGFjZSgvezpbYS16QS1aLi1dK30kLywgXCJcIik7XG4gICAgICAgIHRleHRFbGVtZW50LnZhbHVlID0gc3RyaXBwZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgbGFuZyA9IGtlZXBMYW5nUGFydCA/IFwiXCIgOiBnZXRJbmxpbmVDb2RlTGFuZyh2YWx1ZSwgZGVmYXVsdElubGluZUNvZGVMYW5nKTtcbiAgICAgICAgY29uc3QgaXNMYW5nID0gbGFuZ1swXSAhPT0gXCIuXCI7XG4gICAgICAgIGlmICghbGFuZykgcmV0dXJuO1xuICAgICAgICBsZXQgY29kZVRyZWU7XG4gICAgICAgIGlmIChpc0xhbmcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMobGFuZykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMoXCJwbGFpbnRleHRcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0aGVtZU5hbWVzID0gZ2V0VGhlbWVOYW1lcyh0aGVtZSk7XG4gICAgICAgICAgY29uc3QgaXNNdWx0aVRoZW1lID0gdHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiICYmICFpc0pTT05UaGVtZSh0aGVtZSk7XG4gICAgICAgICAgY29uc3QgdGhlbWVLZXlzID0gaXNNdWx0aVRoZW1lID8gT2JqZWN0LmtleXModGhlbWUpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBjb2xvcnNCeVRoZW1lID0gdGhlbWVOYW1lcy5tYXAoXG4gICAgICAgICAgICAobmFtZSkgPT4gbmFtZSA/IGhpZ2hsaWdodGVyLmdldFRoZW1lKG5hbWUpLnNldHRpbmdzLmZpbmQoXG4gICAgICAgICAgICAgICh7IHNjb3BlIH0pID0+IHNjb3BlPy5pbmNsdWRlcyh0b2tlbnNNYXBbbGFuZy5zbGljZSgxKV0gPz8gbGFuZy5zbGljZSgxKSlcbiAgICAgICAgICAgICk/LnNldHRpbmdzLmZvcmVncm91bmQgPz8gXCJpbmhlcml0XCIgOiBcImluaGVyaXRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzTXVsdGlUaGVtZSAmJiB0aGVtZUtleXMpIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgYDxwcmU+PGNvZGU+PHNwYW4gc3R5bGU9XCIke3RoZW1lS2V5cy5tYXAoKGtleTIsIGkpID0+IGAtLXNoaWtpLSR7a2V5Mn06JHtjb2xvcnNCeVRoZW1lW2ldfWApLmpvaW4oXCI7XCIpfVwiPiR7c3RyaXBwZWRWYWx1ZX08L3NwYW4+PC9jb2RlPjwvcHJlPmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgYDxwcmU+PGNvZGU+PHNwYW4gc3R5bGU9XCJjb2xvcjoke2NvbG9yc0J5VGhlbWVbMF19XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXQoY29kZVRyZWUsIFwiZWxlbWVudFwiLCByZXBsYWNlTGluZUNsYXNzKTtcbiAgICAgICAgYXBwbHkoZWxlbWVudCwge1xuICAgICAgICAgIHRyZWU6IGNvZGVUcmVlLFxuICAgICAgICAgIGxhbmc6IGlzTGFuZyA/IGxhbmcgOiBcIi50b2tlblwiLFxuICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICBrZWVwQmFja2dyb3VuZCxcbiAgICAgICAgICB0aGVtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrQ29kZShlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNFbGVtZW50KGNvZGVFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGNvZGVFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBjb25zdCB7IHRpdGxlLCBjYXB0aW9uLCBtZXRhLCBsYW5nIH0gPSBwYXJzZUJsb2NrTWV0YVN0cmluZyhcbiAgICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgICBmaWx0ZXJNZXRhU3RyaW5nLFxuICAgICAgICAgIGRlZmF1bHRDb2RlQmxvY2tMYW5nXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbGFuZyB8fCBsYW5nID09PSBcIm1hdGhcIikgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaW5lTnVtYmVycyA9IFtdO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBtZXRhLm1hdGNoQWxsKC9cXEJcXHsoLio/KVxcfVxcQi9nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICBsaW5lTnVtYmVycy5wdXNoKC4uLnJhbmdlUGFyc2VyMihtYXRjaFsxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAwO1xuICAgICAgICBjb25zdCBsaW5lSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0TnVtYmVycyA9IFtdO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3RJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNoYXJzTWF0Y2hlcyA9IG1ldGEgPyBbXG4gICAgICAgICAgLi4ubWV0YS5tYXRjaEFsbChcbiAgICAgICAgICAgIC8oPzxkZWxpbWl0ZXI+W1wiL10pKD88Y2hhcnM+Lio/KVxcazxkZWxpbWl0ZXI+KD88Y2hhcnNJZEFuZE9yUmFuZ2U+XFxTKikvZ1xuICAgICAgICAgIClcbiAgICAgICAgXSA6IHZvaWQgMDtcbiAgICAgICAgbGluZU51bWJlcnMuZm9yRWFjaCgobGluZU51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gZ2V0TGluZUlkKGxpbmVOdW1iZXIsIG1ldGEpO1xuICAgICAgICAgIGlkICYmIGxpbmVJZE1hcC5zZXQobGluZU51bWJlciwgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhcnNNYXRjaGVzKSkge1xuICAgICAgICAgIGNoYXJzTWF0Y2hlcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYXJzLCBjaGFyc0lkQW5kT3JSYW5nZSB9ID0gbmFtZS5ncm91cHM7XG4gICAgICAgICAgICBjaGFyc0xpc3QucHVzaChjaGFycyk7XG4gICAgICAgICAgICBpZiAoY2hhcnNJZEFuZE9yUmFuZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgY2hhcnNMaXN0TnVtYmVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtyYW5nZSwgaWRdID0gY2hhcnNJZEFuZE9yUmFuZ2Uuc3BsaXQoXCIjXCIpO1xuICAgICAgICAgICAgICByYW5nZSAmJiBjaGFyc0xpc3ROdW1iZXJzLnB1c2gocmFuZ2VQYXJzZXIyKHJhbmdlKSk7XG4gICAgICAgICAgICAgIGlkICYmIGNoYXJzTGlzdElkTWFwLnNldChjaGFycywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sIFwiXCIpO1xuICAgICAgICBsZXQgY29kZVRyZWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKGxhbmcsIG1ldGEpKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoXG4gICAgICAgICAgICAgIHN0cmlwcGVkVmFsdWUsXG4gICAgICAgICAgICAgIGdldE9wdGlvbnMoXCJwbGFpbnRleHRcIiwgbWV0YSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lQ291bnRlciA9IDA7XG4gICAgICAgIGNvbnN0IGNoYXJzSGlnaGxpZ2h0ZXJPcHRpb25zID0ge1xuICAgICAgICAgIHJhbmdlczogY2hhcnNMaXN0TnVtYmVycyxcbiAgICAgICAgICBpZHNNYXA6IGNoYXJzTGlzdElkTWFwLFxuICAgICAgICAgIGNvdW50ZXJNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgdmlzaXQoY29kZVRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudDIpID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudDIudGFnTmFtZSA9PT0gXCJjb2RlXCIgJiYgL3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvLnRlc3QocmV2ZXJzZVN0cmluZyhtZXRhKSkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Mi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWxpbmUtbnVtYmVyc1wiXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaCA9IHJldmVyc2VTdHJpbmcobWV0YSkubWF0Y2goXG4gICAgICAgICAgICAgIC8oPzpcXH0oXFxkKyl7KT9zcmVibXVOZW5pTHdvaHMoPyEoLiopKFxcLykpL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TnVtYmVyU3RyaW5nID0gbGluZU51bWJlcnNTdGFydEF0TWF0Y2g/LlsxXTtcbiAgICAgICAgICAgIGlmIChzdGFydE51bWJlclN0cmluZykge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydEF0ID0gc3RhcnROdW1iZXJTdHJpbmcgPyBOdW1iZXIocmV2ZXJzZVN0cmluZyhzdGFydE51bWJlclN0cmluZykpIC0gMSA6IDA7XG4gICAgICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gc3RhcnRBdDtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlID0gYGNvdW50ZXItc2V0OiBsaW5lICR7c3RhcnRBdH07YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50Mi5wcm9wZXJ0aWVzPy5jbGFzc05hbWUpICYmIGVsZW1lbnQyLnByb3BlcnRpZXM/LmNsYXNzTmFtZT8uWzBdID09PSBcImxpbmVcIikge1xuICAgICAgICAgICAgaWYgKGdyaWQgJiYgdG9TdHJpbmcoZWxlbWVudDIpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLmNoaWxkcmVuID0gW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIiBcIiB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VMaW5lQ2xhc3MoZWxlbWVudDIpO1xuICAgICAgICAgICAgb25WaXNpdExpbmU/LihlbGVtZW50Mik7XG4gICAgICAgICAgICBsaW5lQ291bnRlcisrO1xuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJzLmluY2x1ZGVzKGxpbmVDb3VudGVyKSkge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1saW5lXCJdID0gXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgbGluZUlkID0gbGluZUlkTWFwLmdldChsaW5lQ291bnRlcik7XG4gICAgICAgICAgICAgIGlmIChsaW5lSWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1saW5lLWlkXCJdID0gbGluZUlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmU/LihlbGVtZW50MiwgbGluZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJzSGlnaGxpZ2h0ZXIoXG4gICAgICAgICAgICAgIGVsZW1lbnQyLFxuICAgICAgICAgICAgICBjaGFyc0xpc3QsXG4gICAgICAgICAgICAgIGNoYXJzSGlnaGxpZ2h0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwbHkoZWxlbWVudCwge1xuICAgICAgICAgIHRyZWU6IGNvZGVUcmVlLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgY2FwdGlvbixcbiAgICAgICAgICBrZWVwQmFja2dyb3VuZCxcbiAgICAgICAgICBncmlkLFxuICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzLFxuICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgIG9uVmlzaXRUaXRsZSxcbiAgICAgICAgICBvblZpc2l0Q2FwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCwgcmVoeXBlUHJldHR5Q29kZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;